import{_ as a,o as l,c as p,a as e,b as n,e as o,d as s,r as i}from"./app.a81d06d1.js";const r={},c=o('<h1 id="vue" tabindex="-1"><a class="header-anchor" href="#vue" aria-hidden="true">#</a> Vue</h1><ol><li><p>Passive is used for mobile terminal operations to perform the default behavior first, not all behaviors, a few</p></li><li><p>Get e.key, e.keyCode and convert key(name) to .kebab-case</p></li><li><p>System modifier keys .ctrl .alt .shift .meta keyup must modify other cases, and trigger after releasing other keys, and keydown triggers directly</p></li><li><p>Vue.config.keyCodes custom keycodes</p></li><li><p>If the page has not changed, the vuedevtools view will not refresh even if the data changes</p></li><li><p>The template will only look for the vm, and the prototype will not look for the global scope, but in js you can put the window on the data body,</p></li><li><p>Compare the diff algorithm between the old virtual dom and the new virtual dom, compare the same keys, keep the same, not redraw the same, the value of the input input box is on the real dom, because the index is used to compare, and the The order is out of order, so there will be errors, and the default &quot;in-place update&quot; strategy is used. It will not move the order of the dom, but update it in place, that is, reuse it for reuse. Or deliberately rely on the default behavior to improve performance (sometimes the default behavior is better).</p></li></ol><blockquote><p>The special attribute of <code>key</code> is mainly used in Vue&#39;s virtual DOM algorithm to identify VNodes when comparing old and new nodes. Without keys, Vue uses an algorithm that minimizes dynamic elements and tries to modify/reuse elements of the same type in-place as much as possible. When using the key, it will rearrange the order of elements based on the change of the key, and will remove/destroy the element whose key does not exist.</p></blockquote><ol start="8"><li>After Vue.set(vm,key,value), the data in observe vm._data has been copied to vm (array can also be manipulated)</li></ol><blockquote><p>\u200B But avoid appending a responsive property to the Vue instance or $data of the root node, it must be used to add new props to the responsive object</p></blockquote><ol start="9"><li><p>It is impossible to modify the array directly by modifying the index value of the array because there is no get, set, but the objects in the array have get, set, and the methods of the array can be detected by vue because these methods are hooked and wrapped (objects). , array, etc. any data type initialization definition has getter and setter, only the index in the array, and newly added, deleted without getter, setter)</p></li><li><p>This explains why if it is a getter, the displayed data is the data after the result, because it is only obtained when clicking..., but if the console.log is to a specific key, it will be different, and it also explains why If I don&#39;t declare form.src it will cause src to not respond</p></li><li><p>The <code>**Object.defineProperty()**</code> method will directly define a new property on an object, or modify an existing property of an object, and return the object. Cannot hijack the index value of adding or deleting arrays, the first parameter can only be an object, p&#39;roxy is invincible, proxy deleteProperty monitors deletion</p></li><li><blockquote><p>Vue executes asynchronously when updating the DOM. As soon as it hears a data change, Vue will open a queue and buffer all data changes that happen in the same event loop. If the same watcher is fired multiple times, it will only be pushed to the queue once.</p></blockquote></li></ol><p>The watch monitor has a getter and a setter to trigger the watch, but triggering the watch will not necessarily refresh the DOM. If the prop is not in the dependency list after the first rendering, the DOM will not be updated even if the watch is triggered, because it is not in the dependency list (ie The property) message queue that is accessed during the rendering process, the job queue opens another watch, and the same queue triggers multiple watches, which will only be pushed into the queue once. But different queues will push multiple times.</p><ol start="13"><li><p>If v-model checkbox is an array, it means adding or deleting value. If it is a string, Boolean means collecting the checked value.</p></li><li><p>.numer is converted to number value type=&#39;&#39;number&#39; can only input number</p></li><li><p>Custom instruction <code>update</code>: called when the component&#39;s VNode is updated, <strong>but may occur before its child VNode is updated</strong>. The value of the instruction may or may not have changed. But you can ignore unnecessary template updates by comparing the values before and after the update, the value of the custom directive should happen in the dom tree update instead of a single bind value change</p></li><li><p>Execute similar foucus in bind, parentnode is invalid, at this time dom has not been successfully mounted, it needs to be in insert</p></li><li><p>The input type change vdom refresh is caused by switching the eye. At this time, the refreshed input and focus must be executed at the same time as nexttick, and mousedown is focus and mouseup is click.</p></li><li><p>BeforeCreated data proxy data monitoring, debugger has no coder custom content, data, method</p></li><li><p>The template option will replace the entire div#app, while el,mouted just mounts</p></li><li><p>BeforeUpdate data is new page is old, next Virtual DOM re-render and patch</p></li><li><p>The getter in vm.$destory() beforeDestroy() destroyed() will not update the view, one is to remove the destroy, and the other is to call the method to destroy, both of which are unbinding instructions, remove event monitoring, and Not really destroy</p></li></ol><blockquote><p>In most scenarios you should not call this method. It is best to use the <code>v-if</code> and <code>v-for</code> directives to control the lifecycle of child components in a data-driven way.</p></blockquote><ol start="22"><li><p>Before this.$forceUpdate() I thought that the logic of adjusting update() was wrong. It should be forced to refresh the DOM, update some DOMs that are not triggered by getters, and the virtual DOM patch will trigger the update</p></li><li><p>Vue.extend creates a component constructor template from the template option or template tag. When using it, register and mount it locally, or create an instance of new $mounted</p></li><li><p>The name of vue devtools depends on the option name, which can be set to pascalcase or kebabcase</p></li><li><p>In non-.vue, the first letter of the tag will be converted to lowercase by html, the rest will not be converted, and the html template cannot recognize uppercase</p></li><li><p>Vue.extend produces component constructors, component constructors 1. Manual new construction() 2. Writing &lt;/&gt; Vue will help us register an instance object to execute Vue.extend, an instance label and a new</p></li><li><p>The prototype of the component constructor is an instance of Vue. The implicit prototype of the display prototype of the component constructor points to the display prototype of Vue, using Object.create</p></li><li><p>index.html</p></li></ol><ul><li><p>noscript does not support js</p></li><li><p><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</code> for IE to use the highest rendering level to render the page</p></li><li><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;</code> to enable ideal viewport on mobile</p></li></ul>',11),d={start:"29"},h=o("<li><p>vue-template-compiler parses .vue template</p></li><li><p>View all configuration items of vue vue inspect &gt; output.js</p></li><li><p>Prop can be a function, then sub-components can pass data through the prop function, prop will report an error only if the basic data type and reference data type address are changed, and the rest will not report an error</p></li><li><p>v-model does not need to write @change for a computed property such as checkbox</p></li><li><p>vm.$refs.cpn.$on(&#39;test&#39;, function (msg) { console.log(msg) }) Manually monitor custom events</p></li><li><p>Because destroy() will teardown watchers child components and event listeners, custom events will be dismantled, whether it is @ or $on bound events will be dismantled, $off can teardown at a specified time, and can be dismantled</p></li><li><p>$emit and $on must be the same instance and the function callback this of $on is not the window but the triggered instance</p></li><li><p>$bus can be added before vue.beforeCreate</p></li><li><p>$set can add some data such as isEdit = false without initialization. It is perfect to use hasOwnProperty&#39;&#39; to prevent repeated $set</p></li><li><p>Animation in active transition in to leave</p></li><li><p>The devServer proxy executes the backend, and the local request points to the local proxy. 1. If it already exists locally, it will not be forwarded. 2. More than one cannot be configured. 1. If the string public already exists, it will not be forwarded.</p></li>",11),u=s("To avoid the above situation, use "),y={href:"https://github.com/chimurai/http-proxy-middleware#proxycontext-config",target:"_blank",rel:"noopener noreferrer"},D=s("http-proxy-middleware"),m=s(" . , configure the prefix for forwarding, otherwise it will not be forwarded, and forwarding will put the prefix Also bring it, you need to configure it not on the official website pathRewrite: {'^/api': '' }, ws proxy websockets , changeOrigin: false, disguise true disguised as server port"),f=o("<li><p>Slots are scoped to parent, but styles are scoped to parent-child</p></li><li><p>Slots with the same name are accumulated instead of overwritten.</p></li><li><p>After installing Vuex, the option store configured in vue will hang $store on the instance</p></li><li><p>Vue.use(Vuex) must be before new Vuex.Store, it cannot be adjusted by adjusting the import order, (it will be advanced) can be adjusted by asynchronous import(&#39;&#39;)</p></li><li><p>The early native of import is like this type=&#39;module&#39; instead of webpack</p></li><li><p>In the module scope, you will receive local dispatch and commit, but instead to use the global one, you need to add { root: true } to the third parameter</p></li><li><p>Register global action or mutation in module scope using handler and root: true,</p></li><li><p>First-level routing plus / remaining level no /</p></li><li><p>/path/:id placeholder pass parameter path/123 params :{id:123}, params must be name, query can be</p></li><li><p>The object mode of routes (dead value) Boolean mode -&gt; params function mode query props: true can make params a props</p></li>",10),g=s("props: route => ({ name: "),b={href:"http://route.query.name",target:"_blank",rel:"noopener noreferrer"},v=s("route.query.name"),w=s(" }) can make name a props"),C=e("li",null,[e("p",null,"If you use the object method to jump, the query will be added after the url, and the params must have a statement to be added after it, otherwise the params will be lost after the refresh")],-1),k=e("li",null,[e("p",null,"keep alive is the component name, so don\u2019t worry about the routing name")],-1),x=e("li",null,[e("p",null,"The part after hash /#/ will not be sent to the server as a path. If the hash mode is equivalent to accessing the server's index.html file all the time, then the path after the hash value is used by sfc itself and Jump, if you use the history mode, you must forward the unreachable path (because you go back and request the file of the corresponding path) to index.html in the backend")],-1),_=e("li",null,[e("p",null,"monorepo management")],-1),j=o(`<ul><li>mono single, repo repository</li><li>Multiple packages are independent of each other, have their own functional logic, unit testing, and are easy to manage under the same warehouse</li><li>The modules are clearly divided, maintainable, and expandable</li></ul><ol start="56"><li>Vue3 uses es6&#39;s Proxy to implement hijacking</li></ol><ul><li>Object.defineProperty used by Vue2.x to hijack the getter and setter of obj. The defect is that setting and deletion cannot be hijacked, so use the corresponding hack methods api$delete, $set,</li></ul><ol start="57"><li>Removed some unnecessary APIs</li></ol><ul><li>Removed $on, $off, $once,</li><li>Removed filter, inline template inline-template (both the data declared in the parent component and the data declared in the child component can be rendered, which is a disadvantage), etc.</li></ul><ol start="58"><li>Compiler optimizations</li></ol><ul><li>Generate block tree, optimize slot compilation, optimize diff algorithm, reduce package size by 41%, initial rendering is 55% faster, update rendering is 133% faster, and memory is reduced by 54%</li><li>Rewrite virtual DOM implementation and achieve better tree-shaking</li></ul><ol start="59"><li>From Options API to Composition Api</li></ol><ul><li>In Vue2.x, the Options API is used to describe component objects, including options such as data, props, methods, computed, life cycle, etc. The problem is that multiple logics may be in different places, jumping around?</li><li>The composition API can put related code on the same line for processing without having to search between multiple Options</li></ul><ol start="60"><li>Hooks function to increase code reusability</li></ol><ul><li>Vue2.x uses mixins to share component logic. The defect is that mixins are also composed of Options. Multiple mixins will have naming conflicts.</li><li>3.x can extract part of the independent logic through the hook function, and it can also be responsive!</li></ul><ol start="61"><li><p>Hugs ts</p></li><li><p>When vite comes up, the server is ready and then requests to analyze the dependencies</p></li><li><p>const app = createApp(App) is lighter</p></li><li><p>setup</p></li></ol><ul><li>the new configuration item is a function before all lifecycles (so no this)</li><li>The returned object is used in templates, or directly returns the render function()=&gt;(&lt;section&gt;&lt;/section&gt;)</li><li>Try not to mix these, vue2.x can access the properties and methods in setup, but not vice versa, there is no this</li><li>If the name is the same, setup takes precedence over object.assign</li><li>If you don&#39;t want to write the root, use &lt;&gt;&lt;/&gt; to write</li></ul><ol start="65"><li><p>refImpl reference implement The reference implementation is automatically expanded in the template. value, render will not automatically expand the instance of the return reference implementation</p></li><li><p>object.define for ref proxy basic data type, proxy for reference, proxy for reactive proxy, ref proxy object actually uses ref(reactive())</p></li><li><p>Ordinary objects in ref will be converted into proxy, accessed through .value,</p></li><li><p>Reading the refImpl in the proxy key will automatically expand the value, but the index value will not automatically expand</p></li><li><p>ref(ref()) reactive(reactive()) returns itself ref(reactive()) reactive(ref()) returns ref</p></li><li><p>The delete keyword has a return value. For example, deleting the key value of an object without configuration and non-enumerable will return false.</p></li><li><p>Object,defineProperty can&#39;t redefine Reflect.defineProperty can</p></li><li><p>Reflect.defineProperty has a return boolean value indicating the success of the proxy</p></li><li><p>this.$slots.default is a vnode so it is used for render instead of template</p></li><li><p>setup has two parameters, the first is the parameter declared by the props option. The second is ctx contains {attrs (props not declared), emit, slots, expose}</p></li><li><p>It seems to only support onSubmit small camel case to listen to events</p></li><li><p>vue3ref The variable generated by ref() is bound to the ref in the template or rendering function, and then the Proxy object of the cpn.value of the component instance can be obtained in the onMounted life cycle, and the parameter expose in the setup can be obtained by ref The instance object is changed to the object exposed by expose</p></li><li><p>The computed return is also a reference implementation instance object, and computed, and watch can only capture changes in responsive data</p></li><li><p>watch listens to multiple calls or passes in an array, and the new value and the old value received are also arrays</p></li><li><ul><li>refer to the same address as the old and new value of the data type (vue2 has this problem),</li></ul></li></ol><ul><li>It seems that you can listen deeply without deep: true, (the proxy object does not need to force the deep function to return the object to need deep, and the function returns the basic data type does not need to be deep.</li><li>The key of the object cannot be monitored in this way. State.count uses the callback function ()=&gt;state.count</li><li>Unable to monitor changes in proxy in ref, as well as changes in objects returned by getter, you need to monitor proxy directly through .value, or enable deep</li></ul><ol start="80"><li><p>Vue3 life cycle app is more lightweight than vm, unmounted, beforeUnmount rename, must be mounted to perform initialization init, (vue2 can be mounted after created)</p></li><li><p>hooks folder useXXX.js</p></li><li><p>Directly return the responsive object or return{...toRefs(responsive object)}, object destructuring to interrupt the responsiveness is the proxy&#39;s pot</p></li><li><p>Direct ref generation of refImp breaks the association and generates a new ref</p></li><li><p>ShallowReactive The first layer of responsiveness, how is it implemented internally??? (The multi-level set of proxy itself will not trigger set, but trigger get</p></li><li><p>) shallowRef does not deal with objects, that is, it does not call reactive internally, the first layer is replaced, or it is a basic type or reactive</p></li><li><p>toRaw returns the source object, there is still the association of the object, but there is no response, two concepts, the address of the object is the same, whether there is a response</p></li><li><p>...toRefs() The template directly accesses the key, but if the key does not exist, an error will be reported, but if the key in the access object is undefined, and the direct template of vue2 accesses data that does not exist in data and the object on data does not exist The data principle is the same</p></li><li><p>markRaw returns an object itself so that it will not be converted into a proxy, lock this object, such as adding a very complex and unchanged object to a proxy object, you can reduce overhead through markRaw</p></li><li><p>The readonly object cannot be changed, but the change of the source object will still cause the change of the readonly object, that is, the proxy and the address are still there, toRaw returns the source object, loses the response, and the address is still the same, markRaw is forcibly unable to proxy.</p></li><li><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#1E1E1E;"><code><span class="line"><span style="color:#569CD6;">const</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">useDebouncedRef</span><span style="color:#D4D4D4;"> = () </span><span style="color:#569CD6;">=&gt;</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#6A9955;">// value can also be a parameter</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#569CD6;">let</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">value</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#C586C0;">return</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">customRef</span><span style="color:#D4D4D4;">((</span><span style="color:#9CDCFE;">track</span><span style="color:#D4D4D4;">, </span><span style="color:#9CDCFE;">trigger</span><span style="color:#D4D4D4;">) </span><span style="color:#569CD6;">=&gt;</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#C586C0;">return</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">      </span><span style="color:#DCDCAA;">get</span><span style="color:#D4D4D4;">() {</span></span>
<span class="line"><span style="color:#D4D4D4;">        </span><span style="color:#9CDCFE;">console</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">log</span><span style="color:#D4D4D4;">(</span><span style="color:#CE9178;">&#39;get&#39;</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"><span style="color:#D4D4D4;">        </span><span style="color:#DCDCAA;">track</span><span style="color:#D4D4D4;">()</span></span>
<span class="line"><span style="color:#D4D4D4;">        </span><span style="color:#C586C0;">return</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">value</span></span>
<span class="line"><span style="color:#D4D4D4;">      },</span></span>
<span class="line"><span style="color:#D4D4D4;">      </span><span style="color:#DCDCAA;">set</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">newVal</span><span style="color:#D4D4D4;">) {</span></span>
<span class="line"><span style="color:#D4D4D4;">        </span><span style="color:#9CDCFE;">console</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">log</span><span style="color:#D4D4D4;">(</span><span style="color:#CE9178;">&#39;set&#39;</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"><span style="color:#D4D4D4;">      }</span></span>
<span class="line"><span style="color:#D4D4D4;">    }</span></span>
<span class="line"><span style="color:#D4D4D4;">  })</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span>
<span class="line"><span style="color:#6A9955;">// The difference from computed is the lack of track, trigger</span></span>
<span class="line"><span style="color:#6A9955;">// Use a variable to receive, display that variable, and customRef only needs one variable</span></span>
<span class="line"></span></code></pre></div></li></ol><div class="language-text ext-text"><pre class="shiki" style="background-color:#1E1E1E;"><code><span class="line"><span style="color:#D4D4D4;"></span></span>
<span class="line"><span style="color:#D4D4D4;">91. Synchronous components, wait for all components to be loaded before rendering, asynchronous components, which are loaded first and rendered first, but this leads to a new problem, that is, the page blank period</span></span>
<span class="line"><span style="color:#D4D4D4;"></span></span>
<span class="line"><span style="color:#D4D4D4;">\`\`\`html</span></span>
<span class="line"><span style="color:#D4D4D4;">&lt;!-- use suspense --&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;">&lt;suspense&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;">&lt;template v-slot:default&gt; &lt;/template&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;">&lt;template v-slot:fallback&gt; &lt;/template&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;">&lt;/suspense&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;"></span></span></code></pre></div><ol start="92"><li>Top level await</li></ol><div class="language-vue ext-vue"><pre class="shiki" style="background-color:#1E1E1E;"><code><span class="line"><span style="color:#808080;">&lt;</span><span style="color:#569CD6;">script</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">setup</span><span style="color:#808080;">&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#C586C0;">await</span><span style="color:#D4D4D4;"> </span><span style="color:#569CD6;">new</span><span style="color:#D4D4D4;"> </span><span style="color:#4EC9B0;">Promise</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">resolve</span><span style="color:#D4D4D4;"> </span><span style="color:#569CD6;">=&gt;</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#DCDCAA;">setTimeout</span><span style="color:#D4D4D4;">(() </span><span style="color:#569CD6;">=&gt;</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">      </span><span style="color:#DCDCAA;">resolve</span><span style="color:#D4D4D4;">(</span><span style="color:#CE9178;">&#39;&#39;</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"><span style="color:#D4D4D4;">    }, </span><span style="color:#B5CEA8;">3000</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"><span style="color:#D4D4D4;">  })</span></span>
<span class="line"><span style="color:#808080;">&lt;/</span><span style="color:#569CD6;">script</span><span style="color:#808080;">&gt;</span></span>
<span class="line"><span style="color:#808080;">&lt;</span><span style="color:#569CD6;">template</span><span style="color:#808080;">&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#808080;">&lt;</span><span style="color:#569CD6;">h1</span><span style="color:#808080;">&gt;</span><span style="color:#D4D4D4;"> demo </span><span style="color:#808080;">&lt;/</span><span style="color:#569CD6;">h1</span><span style="color:#808080;">&gt;</span></span>
<span class="line"><span style="color:#808080;">&lt;/</span><span style="color:#569CD6;">template</span><span style="color:#808080;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>Using await code at the top level of setup will be compiled into async setup(): with suspense and defineAsyncComponent</p><div class="language-vue ext-vue"><pre class="shiki" style="background-color:#1E1E1E;"><code><span class="line"><span style="color:#808080;">&lt;</span><span style="color:#569CD6;">script</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">setup</span><span style="color:#808080;">&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#C586C0;">import</span><span style="color:#D4D4D4;"> { </span><span style="color:#9CDCFE;">defineAsyncComponent</span><span style="color:#D4D4D4;"> } </span><span style="color:#C586C0;">from</span><span style="color:#D4D4D4;"> </span><span style="color:#CE9178;">&#39;vue&#39;</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#569CD6;">const</span><span style="color:#D4D4D4;"> </span><span style="color:#4FC1FF;">Demo</span><span style="color:#D4D4D4;"> = </span><span style="color:#DCDCAA;">defineAsyncComponent</span><span style="color:#D4D4D4;">(() </span><span style="color:#569CD6;">=&gt;</span><span style="color:#D4D4D4;"> </span><span style="color:#569CD6;">import</span><span style="color:#D4D4D4;">(</span><span style="color:#CE9178;">&#39;./Demo.vue&#39;</span><span style="color:#D4D4D4;">))</span></span>
<span class="line"><span style="color:#808080;">&lt;/</span><span style="color:#569CD6;">script</span><span style="color:#808080;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#808080;">&lt;</span><span style="color:#569CD6;">template</span><span style="color:#808080;">&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#808080;">&lt;</span><span style="color:#569CD6;">suspense</span><span style="color:#808080;">&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#808080;">&lt;</span><span style="color:#569CD6;">template</span><span style="color:#D4D4D4;"> #</span><span style="color:#9CDCFE;">default</span><span style="color:#808080;">&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;">      </span><span style="color:#808080;">&lt;</span><span style="color:#4EC9B0;">Demo</span><span style="color:#D4D4D4;"> /</span><span style="color:#808080;">&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#808080;">&lt;/</span><span style="color:#569CD6;">template</span><span style="color:#808080;">&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#808080;">&lt;</span><span style="color:#569CD6;">template</span><span style="color:#D4D4D4;"> #</span><span style="color:#9CDCFE;">fallback</span><span style="color:#808080;">&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;">      </span><span style="color:#808080;">&lt;</span><span style="color:#569CD6;">h1</span><span style="color:#808080;">&gt;</span><span style="color:#D4D4D4;"> loading...Loading</span><span style="color:#808080;">&lt;/</span><span style="color:#569CD6;">h1</span><span style="color:#808080;">&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#808080;">&lt;/</span><span style="color:#569CD6;">template</span><span style="color:#808080;">&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#808080;">&lt;/</span><span style="color:#569CD6;">suspense</span><span style="color:#808080;">&gt;</span></span>
<span class="line"><span style="color:#808080;">&lt;/</span><span style="color:#569CD6;">template</span><span style="color:#808080;">&gt;</span></span>
<span class="line"></span></code></pre></div><ol start="93"><li><p>The file:/// protocol needs to set the publicPath to ./ and the hash mode. The cookie cannot be used. The cookie is the product of http</p></li><li><p>hook</p></li></ol><p>Replace destroyed api: <code>$on(&#39;hook:xxx&#39;)</code></p><p>@hook:mounted=&#39;doSomething&#39; monitors the life cycle of child components</p><ol start="95"><li>Performance Optimization Tips</li></ol><p>The JS engine is a single-threaded operation mechanism. The JS thread will block the UI thread, so when the script execution time is too long, the rendering will be blocked, causing the page to freeze. <code>script</code> has a short execution time, so it performs better.</p>`,26),E={href:"https://slides.com/akryum/vueconfus-2019#/",target:"_blank",rel:"noopener noreferrer"},A=s("vue-9-perf-secrets "),T=s(),F={href:"https://juejin.cn/post/6922641008106668045#heading-2",target:"_blank",rel:"noopener noreferrer"},I=s("Nuggets"),q=o(`<ol><li>Function components</li></ol><p>A large number of reused sub-components without responsive data use functional components. Unlike ordinary object-type components, functional components will not be regarded as a real component. We know that in the <code>patch</code> process, if you encounter A node is the component <code>vnode</code>, which recursively executes the initialization process of subcomponents; while the <code>render</code> of functional components generates a normal <code>vnode</code>, and there is no recursive subcomponent process, so the rendering overhead will be much lower. So functional components don&#39;t have state, they don&#39;t have reactive data, they don&#39;t have lifecycle hooks. You can think of it as stripping out a part of the DOM in the normal component template and rendering it through a function, which is a kind of reuse at the DOM level</p><ol start="2"><li>child component splitting</li></ol><p>The execution logic of this time-consuming task <code>heavy</code> function is encapsulated with the child component <code>ChildComp</code>. Since the update of Vue is component granularity, although the data modification of each frame leads to the re-rendering of the parent component, the <code>ChildComp</code> But it won&#39;t re-render because it doesn&#39;t have any responsive data changes inside it either. Therefore, the optimized component will not perform time-consuming tasks on each rendering, and the natural execution time of JavaScript will be reduced. Reduced re-rendered components</p><ol start="3"><li>local variables</li></ol><p>When a large number of repeated operations of this are performed, the cache is localized first, and computed passes this in by default.</p><ol start="4"><li>reuse dom with v-show</li></ol><p>Use v-show instead of v-if</p><ol start="5"><li>keep-alive</li></ol><p>Space for time, occupying memory cache</p><ol start="6"><li>Deferred features</li></ol><p>Rendering in batches using the <code>Defer</code> mixin</p><ol start="7"><li>time slicing</li></ol><p>When the script execution time is too long, it may be stuck</p><ol start="8"><li>Non-reactive data</li></ol><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#1E1E1E;"><code><span class="line"><span style="color:#569CD6;">const</span><span style="color:#D4D4D4;"> </span><span style="color:#4FC1FF;">data</span><span style="color:#D4D4D4;"> = </span><span style="color:#9CDCFE;">items</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">map</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">item</span><span style="color:#D4D4D4;"> </span><span style="color:#569CD6;">=&gt;</span><span style="color:#D4D4D4;"> ({</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#9CDCFE;">id:</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">uid</span><span style="color:#D4D4D4;">++,</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#9CDCFE;">data:</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">item</span><span style="color:#D4D4D4;">,</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#9CDCFE;">vote:</span><span style="color:#D4D4D4;"> </span><span style="color:#B5CEA8;">0</span></span>
<span class="line"><span style="color:#D4D4D4;">}))</span></span>
<span class="line"><span style="color:#6A9955;">// The object key is responsive, which increases the overhead. When the amount of data is large, the script overhead is delayed</span></span>
<span class="line"></span></code></pre></div><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#1E1E1E;"><code><span class="line"><span style="color:#569CD6;">const</span><span style="color:#D4D4D4;"> </span><span style="color:#4FC1FF;">data</span><span style="color:#D4D4D4;"> = </span><span style="color:#9CDCFE;">items</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">map</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">item</span><span style="color:#D4D4D4;"> </span><span style="color:#569CD6;">=&gt;</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">optimizeItem</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">item</span><span style="color:#D4D4D4;">))</span></span>
<span class="line"></span>
<span class="line"><span style="color:#569CD6;">function</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">optimizeItem</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">item</span><span style="color:#D4D4D4;">) {</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#569CD6;">const</span><span style="color:#D4D4D4;"> </span><span style="color:#4FC1FF;">itemData</span><span style="color:#D4D4D4;"> = {</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#9CDCFE;">id:</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">uid</span><span style="color:#D4D4D4;">++,</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#9CDCFE;">vote:</span><span style="color:#D4D4D4;"> </span><span style="color:#B5CEA8;">0</span></span>
<span class="line"><span style="color:#D4D4D4;">  }</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#4EC9B0;">Object</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">defineProperty</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">itemData</span><span style="color:#D4D4D4;">, </span><span style="color:#CE9178;">&#39;data&#39;</span><span style="color:#D4D4D4;">, {</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#6A9955;">// Mark as non-reactive</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#9CDCFE;">configurable:</span><span style="color:#D4D4D4;"> </span><span style="color:#569CD6;">false</span><span style="color:#D4D4D4;">,</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#9CDCFE;">value:</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">item</span></span>
<span class="line"><span style="color:#D4D4D4;">  })</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#C586C0;">return</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">itemData</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span>
<span class="line"></span></code></pre></div><p>Similarly, if you want to share a piece of data in the context, it does not necessarily have to be bound to the data</p><ol start="9"><li>virtual scrolling</li></ol><p>The reason for this difference is that virtual scrolling is implemented by rendering only the DOM in the viewport, so that the total number of rendered DOMs is very small, and the natural performance will be much better.</p>`,20),V=s("The virtual scrolling component is also written by "),O={href:"https://github.com/Akryum",target:"_blank",rel:"noopener noreferrer"},R=s("Guillaume Chau"),$=s(", and interested students can study its [source code implementation]("),M={href:"https://github.com/Akryum/vue-virtual-",target:"_blank",rel:"noopener noreferrer"},B=s("https://github.com/Akryum/vue-virtual-"),P=s(" scroller). Its basic principle is to listen to scroll events, dynamically update the DOM elements that need to be displayed, and calculate their displacement in the view."),S=e("p",null,[s("The virtual scroll component is not without cost, because it needs to be calculated in real time during the scrolling process, so there will be a certain "),e("code",null,"script"),s(" execution cost. So if the amount of data in the list is not very large, we can use normal scrolling.")],-1);function z(N,U){const t=i("ExternalLinkIcon");return l(),p("div",null,[c,e("ol",d,[h,e("li",null,[e("p",null,[u,e("a",y,[D,n(t)]),m])]),f,e("li",null,[e("p",null,[g,e("a",b,[v,n(t)]),w])]),C,k,x,_]),j,e("p",null,[e("a",E,[A,n(t)]),T,e("a",F,[I,n(t)])]),q,e("p",null,[V,e("a",O,[R,n(t)]),$,e("a",M,[B,n(t)]),P]),S])}var J=a(r,[["render",z],["__file","vue.html.vue"]]);export{J as default};
