# Webpack <NpmBadge package="webpack" />

## Install

````javascript
webpack below 4.0 ./src/index.js ./dist/bundle.js ->bundle.js
4.0 and above also requires webcli webpack ./src/index.js -o ./dist ->main.js
````

4.0 and above install `"webpack-cli": "^4.1.0"`

By default running node_modules through script script to find locally

````json
// webpack will look for webpack.config.js in the root directory
"scripts": {
"start": "webpack"
}
````

## Getting started

Remove the `main` entry. This prevents accidental release of your code. [npm](https://docs.npmjs.com/files/package.json)

`<script>` tag management project problem

1. Implicit dependencies, which cannot be reflected immediately, the execution of the script depends on the external library (external library)
2. If the dependency does not exist, or if the sequence error is introduced, the application will not function properly
3. If a dependency is imported but not used, the browser will be forced to download useless code

`npx webpack`, will take our script as [entry-points](https://www.webpackjs.com/concepts/entry-points), and [output](https://www.webpackjs.com/concepts/ output) as `main.js`. The `npx` command provided by Node 8.2+ can run webpack binaries in the initially installed webpack package

_Note that backslashes must be used when calling _ `webpack` _ via the calling path on Windows. For example _ `node_modules\.bin\webpack --config webpack.config.js`_. _

_Custom arguments can be passed to webpack by adding two dashes between the `npm run build`_ command and your arguments, for example: _`npm run build -- --colors`_. _

## Manage resources

Dynamically package all dependencies, _introduce any other type of file_ through the loader.

````javascript
{
test: /\.(png|svg|jpeg|gif)$/,
use: [{
loader: 'file-loader',
options: {
outputPath: './img'
// publicPath: './img'
}
}]
}
````

webpack decides which files to use which loaders based on regular expression matching

By default, css will be injected into the main.js file. In most cases, css separation (using the extract-text-webpack-plugin plugin) is conducive to improving the loading speed of the production environment.

`use: [ 'style-loader', 'css-loader' ]`The order is important, the loading order is right-to-do

1. Load Css [style-loader](https://www.webpackjs.com/loaders/style-loader) (inject css-loader internal styles into our HTML page) and [css-loader](https:/ /www.webpackjs.com/loaders/css-loader) (loads .css files):

2. file-loader, load images, fonts and transfer them to the dist folder

3. When the file size is small, you can use `url-loader` The function is similar to [`file-loader`](https://github.com/webpack-contrib/file-loader), but the file size (unit byte) is lower A DataURL can be returned when the specified limit is exceeded.

4. Load data such as JSON files, CSV, TSV and XML using [csv-loader](https://github.com/theplatapi/csv-loader) and [xml-loader](https://github.com/gisikw /xml-loader). Let's deal with these three types of files:

Before webpack, front-end developers used tools like grunt and gulp to process assets

5. url loader limit: When the size of the image kb\*1024 is less than the limit, the image will be compiled into a bae64 string and saved directly in the file. If it is larger than the file loader, the image will be packaged into dist

## manage output

Once you start hashing filenames and exporting multiple bundles, you need to manually mount multiple bundles to index.html, and everything becomes difficult.

Use HtmlWebpackPlugin to manage output HtmlWebpackPlugin will generate index.html file by default. That said, it will replace our original with the newly generated index.html file. The new index.html imports all bundle.js

Use clean-webpack-plugin to clean dist folder before every bundle `const { CleanWebpackPlugin } = require('clean-webpack-plugin')`

Use HtmlWebpackPlugin html to automatically associate packaged js files

Clean the folder with [`clean-webpack-plugin`](https://www.npmjs.com/package/clean-webpack-plugin)

webpack and its plugins seem to "know" which files should be generated. The answer is, through manifest

## development

source map source files will be packaged and integrated into a bundle.js, it is difficult to track which source file errors and warnings come from

Choose a watch development tool

1. webpack's Watch Mode "watch": "webpack --watch", repack when code modification is detected
2. webpack-dev-server webpack-cli@3
3. webpack-dev-middleware

webpack server only needs to be configured

````javascript
devServer: {
contentBase: './dist'
}
````

The above configuration tells `webpack-dev-server` to create a service under `localhost:8080`, and use the files in the `dist` directory as accessible files.

The bundle.js file generated by webpack-dev-server packaged for us is not placed on the actual physical disk; it is directly hosted in the computer's memory, so we cannot find this package in the project root directory at all good bundle.js;

`webpack-dev-middleware` is a container (wrapper) that can pass webpack processed files to a server (server). `webpack-dev-server` uses it internally, and at the same time, it is also available as a separate package for more customization to achieve more needs. Combined with server, koa,

````javascript
const config = require('./webpack.config.js')
const compiler = webpack(config) generates a compiler
````

## Module hot swap

HMR Hot Module Replacement which allows various modules to be updated at runtime without a full refresh

Never enable plugins imported by HMR in production environment will make the bundle very large

When using both the webpack dev server and the Node.js API, do not put the dev server option in the webpack config object. Instead, when creating the option, pass it as the second parameter. That is, when webpack-dev-server and webpack-dev-middleware are used in combination with server

Module hot replacement of js files needs to use module.hot.accept to monitor and modify css, hmr is very easy, the loader will `module.hot.accept` in the background to patch (patch) `<style>` tags.

## Tree shaking

Tree shaking is a term commonly used to describe the removal of dead-code from a JavaScript context.

The default packaging of webpack5+ is to use the production environment, the default treeshaking, if `--mode = development` is used, the dead-code will also be packaged into the bundle

The new official version of webpack 4 extends this detection capability, using the `"sideEffects"` property of `package.json` as a marker to provide hints to the compiler, indicating which files in the project are "pure (pure ES2015 modules)" , which allows you to safely delete unused parts of the file.

Set the field sideEffects to false in package.json, and webpack will safely delete the unused export with the same effect as `babel-plugin-import`

A "side effect" is defined as code that performs special behavior when imported, rather than just exposing an export or exports. For example, such as polyfills, which affect the global scope and generally do not provide export. Some code fields have side effects, sideEffects can be set as an array

Compress output, either *UglifyJSPlugin* set mde export mode, or `webpack --mode production`

## Production build

Development environment: We need a powerful source map and localhost server with live reloading or hot module replacement capabilities.

Production: Smaller bundles, lighter source maps, and more optimized resources to improve load times. Due to logical separation

Follow the principle of not repeating DRY don'trepeatyourself, extract the common configuration, and use `webpack-merge` to merge

`webpack.base.conf.js webpack.dev.conf.js webpack.prod.conf.js`

The useful Minification plugins [babel-minify-webpack-plugin](https://github.com/webpack-contrib/babel-minify-webpack-plugin) and [webpack-closure-compiler](https://github. com/roman01la/webpack-closure-compiler)

It is recommended to use `devtool: 'source-map'` in the production environment, which is a map file independent of the bundle file, different from the inlint-source-map in the development environment

Use `new webpack.DefinePlugin({ 'process.env.NODE_ENV': JSON.stringify('production') })` to set the global variable NODE_ENV, scope bundle

> _Technically, _`NODE_ENV`_ is a system environment variable exposed by Node.js to executing scripts. Used to determine the behavior of server tools, build scripts, and client libraries in development and production (dev-vs-prod) environments. However, as expected, it is not possible to set _ `process.env.NODE_ENV` _ to _ `"production"`_ in the build script _ `webpack.config.js` _, see _ [#2537] (https://github.com/webpack/webpack/issues/2537)_. Therefore, conditional statements such as `process.env.NODE_ENV === 'production' ? '[name].[hash].bundle.js' : '[name].bundle.js'` _ are configured in webpack file, doesn't work as expected. _

**split css**

1. webpack 4 : mini-css-extract-plugin
2. webpack 3: extract-text-webpack-plugin

css minification: css-minimizer-webpack-plugin

## code separation

Separating the code into different bundles can then load these files on demand or in parallel. Code separation can be used to obtain smaller bundles and to control resource loading priorities, which can greatly affect loading times if used properly.

1. Entry Origin: Manually separate code using the [`entry`](https://www.webpackjs.com/configuration/entry-context) configuration. Stupid method (repeated, if the entry files depend on each other, they will be imported circularly, not flexible enough)
2. Prevent duplication: use [`CommonsChunkPlugin`](https://www.webpackjs.com/plugins/commons-chunk-plugin) . Remove duplicate dependent modules
3. Dynamic import: code is separated by inline function calls of modules.

ExtractTextPlugin: Used to separate CSS from the main application.

bundle-loader: Used to separate code and lazy load generated bundles.

promise-loader: Similar to bundle-loader, but uses promises.

The CommonsChunkPlugin plugin can also separate vendor modules from application code by using the explicit vendor chunks feature.

Just configure `output chunkFilename: '[name].bundle.js'` to separate dynamic imports into a separate `bundle /_ webpackChunkName: "lodash" _/` named

**bundle analysis**

1. webpack-chart: webpack data interaction pie chart.
2. webpack-visualizer: Visualize and analyze your bundles, check which modules take up space and which may be reused.
3. webpack-bundle-analyzer: A plug-in and CLI tool for analyzing bundle content, displaying it to users in a convenient, interactive, and scalable tree diagram.

## lazy loading

Lazy loading, or on-demand loading, is a great way to optimize web pages or applications. This method actually separates your code at some logical breakpoints, and then references or is about to reference other new code blocks after completing certain operations in some code blocks. This speeds up the initial loading of the app and reduces its overall size, as some blocks of code may never be loaded.

As long as the function is introspectively separated by module, the chunk will be separated according to the `filename: 'bundle.[name].js', chunkFilename: '[name].bundle.js'` naming format

## cache

The packaged /dist is deployed to the server, and the browser can access the website and its resources of this server. Getting resources is time-consuming, so browsers use a technology called [cache](https://searchstorage.techtarget.com/definition/cache). Hitting the cache can reduce network traffic and make the website load faster, however, if we deploy a new version without changing the filename of the resource, the browser may think it has not been updated and will use its cached version . Because of the cache, when you need to fetch new code, it can be tricky. Causes the code to be updated without the browser to reset

Set `filename: '[name].[chunkhash].js'` to make the packaged file named differently
