# 基础要素

## 时间复杂度

算法的时间复杂度是一个函数,时间复杂度通常用 O 符号表述

- ![[公式]](https://www.zhihu.com/equation?tex=O%281%29) 运行时间和输入大小无关，都在固定时间内算完。⽐如说四则运算。

- ![[公式]](https://www.zhihu.com/equation?tex=O%28log%28N%29%29) 我每多提供一倍的麦子，他只多消耗一个格子 比起![[公式]](https://www.zhihu.com/equation?tex=O%28N%29)它更接近![[公式]](https://www.zhihu.com/equation?tex=O%281%29)每操作一次，需要处理的规模就小一半的.既二分搜索 ![[公式]](https://www.zhihu.com/equation?tex=O%28N%29) : 随着输入规模的增加，运行时间线性增加。

- ![[公式]](https://www.zhihu.com/equation?tex=O%28Nlog%28N%29%29)：???

- ![[公式]](https://www.zhihu.com/equation?tex=O%28N%5E2%29) ：随着输入规模的增加，运行时间次方增加。

排序方式

- in-place 占用常数内存，不占用额外内存
- out-place 占用额外内存

通常使⽤最差的时间复杂度来衡量⼀个算法的好坏。

当使用两个算法的时候可能会出现两个算法都是 ![[公式]](https://www.zhihu.com/equation?tex=O%28N%29) 的时间复杂度，那么对⽐两个算法的好坏就要通过对⽐低阶项和常数项了。

## 位运算

位运算在算法中很有⽤，速度可以⽐四则运算快很多。

在学习位运算之前应该知道⼗进制如何转⼆进制，⼆进制如何转⼗进制。这⾥说明下简单的计算⽅式

- ⼗进制 33 可以看成是 32 + 1 ，并且 33 应该是六位⼆进制的（因为 33 近似 32 ， ⽽ 32 是 2 的五次⽅，所以是六位），那么 ⼗进制 33 就是 100001 ，只要是 2 的次⽅，那么就是 1 否则都为 0

- 那么⼆进制 100001 同理，⾸位是 2^5 ，末位是 2^0 ，相加得出 33

### 左移 <<

```
10 << 1 // -> 20
```

左移就是将⼆进制全部往左移动， 10 在⼆进制中表示为 1010 ，左移⼀位后变成 10100 ，转换为⼗进制也就是 20，所以基本可以把左移看成以下公式 a \* (2 ^ b)

### 算数右移 >>

```
10 >> 1 // -> 5
```

算数右移就是将⼆进制全部往右移动并去除多余的右边， 10 在⼆进制中表示为 1010 ，右移⼀位后变成 101 ，转换为⼗进制也就是 5，所以基本可以把右移看成以下公式 int v = a / (2 ^ b)

右移很好⽤，⽐如可以⽤在⼆分算法中取中间值

```
13 >> 1 // -> 6
```

### 按位操作

#### 按位与

每⼀位都为 1，结果才为 1

```
8 & 7 // -> 0
// 1000 & 0111 -> 0000 -> 0
```

#### 按位或

其中⼀位为 1，结果就是 1

```
8 | 7 // -> 15
// 1000 | 0111 -> 1111 -> 15
```

#### 按位异或

每⼀位都不同，结果才为 1

```
8 ^ 7 // -> 15
8 ^ 8 // -> 0
// 1000 ^ 0111 -> 1111 -> 15
// 1000 ^ 1000 -> 0000 -> 0
```

从以上代码中可以发现按位异或就是不进位加法

## Review

- 两个数不使⽤四则运算得出和

  这道题中可以按位异或，因为按位异或就是不进位加法， 8 ^ 8 = 0 如果进位了，就是 16 了，所以我们只需要将两个数进⾏异或操作，然后进位。那么也就是说两个⼆进制都是 1 的位置，左边应该有⼀个进位 1，所以可以得出以下公式 a + b = (a ^ b) + ((a & b) <<

  ```javascript
  function sum(a, b) {
    if (a == 0) return b
    if (b == 0) return a
    let newA = a ^ b
    let newB = (a & b) << 1
    return sum(newA, newB)
  }
  ```
