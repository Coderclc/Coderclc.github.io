# 动态规划

动态规划背后的基本思想⾮常简单。就是将⼀个问题拆分为⼦问题，⼀般来说这些⼦问题都是⾮常相似的，那么我们可以通过只解决⼀次每个⼦问题来达到减少计算量的⽬的。

⼀旦得出每个⼦问题的解，就存储该结果以便下次使⽤。

## 斐波那契数列

斐波那契数列就是从 0 和 1 开始，后⾯的数都是前两个数之和

0，1，1，2，3，5，8，13，21，34，55，89....

那么显然易⻅，我们可以通过递归的⽅式来完成求解斐波那契数列

```javascript
function fib(n) {
  if (n < 2 && n >= 0) return n
  return fib(n - 1) + fib(n - 2)
}

fib(10)
```

以上代码已经可以完美的解决问题。但是以上解法却存在很严重的性能问题，当 n 越⼤的时候，需要的时间是指数增⻓的，这时候就可以通过动态规划来解决这个问题。

动态规划的本质其实就是两点

- ⾃底向上分解⼦问题
- 通过变量存储已经计算过的解

根据上⾯两点，我们的斐波那契数列的动态规划思路也就出来了

- 斐波那契数列从 0 和 1 开始，那么这就是这个⼦问题的最底层
- 通过数组来存储每⼀位所对应的斐波那契数列的值

```javascript
function fib(n) {
  let array = new Array(n + 1).fill(null)
  array[0] = 0
  array[1] = 1
  for (let i = 2; i <= n; i++) {
    array[i] = array[i - 1] + array[i - 2]
  }
  return array[n]
}
fib(10)
```

## 0 - 1 背包问题

该问题可以描述为：给定⼀组物品，每种物品都有⾃⼰的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最⾼。每个问题只能放⼊⾄多⼀次。

假设我们有以下物品

| 物品 ID / 重量 | 价值 |
| :------------: | :--: |
|       1        |  3   |
|       2        |  7   |
|       3        |  12  |

对于⼀个总容量为 5 的背包来说，我们可以放⼊重量 2 和 3 的物品来达到背包内的物品总价值最⾼。

对于这个问题来说，⼦问题就两个，分别是放物品和不放物品，可以通过以下表格来理解⼦问题

| 物品 ID / 剩余容量 |  0  |  1  |  2  |  3  |  4  |  5  |
| :----------------: | :-: | :-: | :-: | :-: | :-: | :-: |
|         1          |  0  |  3  |  3  |  3  |  3  |  3  |
|         2          |  0  |  3  |  7  | 10  | 10  | 10  |
|         3          |  0  |  3  |  7  | 12  | 15  | 19  |

- 当容量少于 3 时，只取上⼀⾏对应的数据，因为当前容量不能容纳物品 3
- 当容量 为 3 时，考虑两种情况，分别为放⼊物品 3 和不放物品 3
  - 不放物品 3 的情况下，总价值为 10
  - 放⼊物品 3 的情况下，总价值为 12，所以应该放⼊物品 3
- 当容量 为 4 时，考虑两种情况，分别为放⼊物品 3 和不放物品 3
  - 不放物品 3 的情况下，总价值为 10
  - 放⼊物品 3 的情况下，和放⼊物品 1 的价值相加，得出总价值为 15，所以应该放⼊ 物品 3
- 当容量 为 5 时，考虑两种情况，分别为放⼊物品 3 和不放物品 3
  - 不放物品 3 的情况下，总价值为 10
  - 放⼊物品 3 的情况下，和放⼊物品 2 的价值相加，得出总价值为 19，所以应该放⼊物品 3

以下代码对照上表更容易理解
